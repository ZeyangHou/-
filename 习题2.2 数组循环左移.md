习题2.2 数组循环左移
==
本题要求实现一个对数组进行循环左移的简单函数：一个数组a中存有n（>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向左移m（≥0）个位置，即将a中的数据由（a0 a1 ⋯ an−1）变换为（am ⋯ an−1 a0 a1 ⋯ am−1）（最前面的m个数循环移至最后面的m个位置）。如果还需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？

输入格式:

输入第1行给出正整数n（≤100）和整数m（≥0）；第2行给出n个整数，其间以空格分隔。

输出格式:

在一行中输出循环左移m位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。

输入样例：
```
8 3
1 2 3 4 5 6 7 8
```
输出样例：
```
4 5 6 7 8 1 2 3
```
my program:
==
```
#include <iostream>
using namespace std;
void arrrev(int* a,int lo,int hi)
{
    int temp,i=lo,j=hi;
    while(i<j)
    {
        temp=a[i];
        a[i]=a[j];
        a[j]=temp;
        i++;
        j--;
    }
}
int main()
{
    int m,n;
    int a[1000];
    cin>>m>>n;
    for(int i=0;i<m;i++)
    {
        cin>>a[i];
    }
    if(n>=m)
        n=n%m;
    arrrev(a,0,m-1);
    arrrev(a,0,m-1-n);
    arrrev(a,m-n,m-1);
    for(int i=0;i<m-1;i++)
    {
        cout<<a[i]<<' ';
    }
    cout<<a[m-1];
    return 0;
}
```
总结：
==
本题要求不借助其他数组对数组进行循环左移，而且要求移动次数尽量少。

注意要区分移动次数n大于数组长度m的情况。当n>m时，可以简化为n=n%m。

正常的暴力方法（即一个一个挨着移动）需要移动的次数是m*(n%m)，本程序中我们借用了一个arrrev函数对数组的指定部分进行逆转，因为本题目要求的循环左移可以分解为：先将数组总体逆转，再逆转前m-(n%m)个，再逆转后n%m个。这样就只需要移动2*m次。
