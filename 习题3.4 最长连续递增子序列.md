习题3.4 最长连续递增子序列
==
给定一个顺序存储的线性表，请设计一个算法查找该线性表中最长的连续递增子序列。例如，(1,9,2,5,7,3,4,6,8,0)中最长的递增子序列为(3,4,6,8)。

输入格式:
输入第1行给出正整数n（≤10^5）；第2行给出n个整数，其间以空格分隔。

输出格式:
在一行中输出第一次出现的最长连续递增子序列，数字之间用空格分隔，序列结尾不能有多余空格。

输入样例：
```
15
1 9 2 5 7 3 4 6 8 0 11 15 17 17 10
```
输出样例：
```
3 4 6 8
```
my program:
==
```
#include <iostream>
using namespace std;
int main()
{
    int a[100010];
    int totnum,num1=1,num2=0,beg=0;
    cin>>totnum;
    cin>>a[0];
    for(int i=1;i<totnum;i++)
    {
        cin>>a[i];
        if(a[i]>a[i-1])
        {
            num1++;
        }
        else
        {
            if(num1>num2)
            {
                num2=num1
                beg=i-num2;
            }
            num1=1;
        }
    }
    if(num1>num2)
    {
        num2=num1;
        beg=totnum-num2;
    }
    for(int i=beg;i<num2+beg-1;i++)
        cout<<a[i]<<' ';
    cout<<a[num2+beg-1];
    return 0;
}
```
总结：
==
本题的思路类似于课本上的在线处理最大子列和，即一边读取新的数据，然后将其与数组中的前一个数据比较，如果大于前一个数据则更新当前递增子列的长度num1，否则说明当前的递增子列已经结束，进入到下一轮可能的递增子列，此时要比较当前的子列和长度与此前出现过的最大子列和的长度num2，如果num1更大，则说明出现了新的最长连续递增子列，则需要更新num2，并记录当前最长连续第增子列的起点beg。
num1同样也要更新，但是num1的更新与num1是否大于num2无关，只要前一个递增子列结束，num1就应该置一，以便开始下一轮计数。
上述对num2的更新是在出现了新的更长的连续递增子列时发生的，这就要求最长的连续递增子列不能在数组的最末尾（及最长连续递增子列结束后数组也结束了，没有一个a[i]<=a[i-1]发生从而使num2得到更新），而这种情况也是有可能发生的，这就需要在for循环之外再增加一次对num2的更新，来处理整个数组就是一个连续递增子列的情况，还有虽然有多个连续递增子列，但是最长连续递增子列在数组的最末尾的情况。
